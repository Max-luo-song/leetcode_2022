/*
    算法思想：本题容易分析出是动态规划问题，但状态转移表达式和初始化较难
    首先按照n=3分析，易得n为1时是1，n为2时是2。n=3有三种情况，分别是123分别做根。13做根时与2的分布相同，2做根的时候与1分布相同。所以对于n来说，从1到n可分别做根。
    dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
    所以dp[n]代表就是所有索引和为n-1的乘积之和
    因为子树为空就是dp[0]要从dp[0]开始赋值
*/
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=i; j++) { // 控制dp[0]的情况j可以等于i
                dp[i] += dp[j-1]*dp[i-j]; // 代表i-1的乘积之和
            }
        }
        return dp[n];
    }
};
