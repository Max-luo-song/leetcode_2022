1.AVL树定义，满足二叉搜索树，并且左右子树高度相差小于1
2.二叉树节点的定义方式
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x):val(x),left(NULL),right(NULL){}
};
3.递归算法的三要素
1）确定递归函数的参数和返回值
2）确定终止条件
3）确定单层递归的逻辑
4.二叉树后序遍历(左右中)的思路：先导入中右左，再翻转。为了中右左，入栈的顺序是中左右。详见145
5.对于二叉树前中后序遍历(递归和非递归)以及层次遍历都要掌握
6.二叉树的问题，解题之前首先确定遍历的方式(前中后层序)
7.实现二叉树的翻转，就是递归前序遍历交换左右节点后。递归左右节点就行了。详见226
8.判断对称二叉树可以用后序遍历实现迭代法，可以用队列实现非迭代法。注意比较的对象左左和右右，左右和右左。详见101
9.求二叉树的最大深度，递归法使用后序遍历，迭代法使用层序遍历。详见104
10.求二叉树最小深度，迭代法使用层序遍历，碰到叶子节点就算。递归法返回值还是NULL为0，单层逻辑是左子树为空返回右子树+1，右子树为空返回左子树+1。全为空，返回左右较小的加一。详见111
11.求完全二叉树个数时，可以使用常规二叉树的方法。各种遍历方法。还可以利用完全二叉树特性，递归实现。对于完全二叉树，分类实现：满二叉树2^n-1，完全二叉树利用左右节点数+1。详见222
12.判断平衡二叉树，左右高度超过1返回true。但返回值不使用bool，用int来代替。返回值-1说明左右节点擦差距大于1.否则正常返回当前节点高度。详见110
13.求二叉树的所有路径，要使用回溯法来完成。按照回溯模板，确定返回值，确定逻辑，确定回溯值。详见257
14.凡是有关于根节点到叶子节点的相关题目，都是通过回溯来完成的
15.利用中序及前后序构造二叉树的方法是：确定根(后序最后一个，前序第一个)。根据根值划分中序队列，左边是左子树，右边是右子树。利用递归实现。要使用循环不变量——左闭右开。划分后序左子树时利用和中序左子树个数相同。注意参数声明：TreeNode* traverse(vector<int>& inorder, int inorder_begin, int inorder_end, vector<int>& postorder, int postorder_begin, int postorder_end)。详见106
16.递归函数是否需要返回值？分情况
1）搜索整颗二叉树且不处理递归返回值，递归函数不要返回值
2）搜索整颗二叉树要处理递归返回值，递归函数需要返回值
3）搜索一条符合的路径(不遍历整棵树)，需要返回值
17.合并二叉树时递归法直接对根节点进行操作，其中有一个为空返回另一个。在递归左子树作为新的左子树，递归右子树作为新的右子树。使用迭代法时同时操作两颗树就要使用队列来完成。成对操作，同进同出两个。如果其中一个为NULL，要用另一个替过去。详见617
18.面对二叉搜索树时，使用迭代法可以用while(root != NULL)来处理。详见700
19.判断是不是一颗二叉搜索树时，使用方法中序遍历是否有序。不能使用根节点大于左节点小于右节点的方法，二叉搜索树要实现根节点大于左子树。详见98
20.对二叉搜索树做处理时还可以使用双指针法，使用的模板是：
TreeNode *pre;
traverse(cur->left);
// 处理cur
// pre = cur;
traverse(cur->right);
21.对于二叉搜索树的众数问题，要使用双指针法结合中序遍历。count不断增加，遇到更大的count清空原来的(适时清空结果集)。详见501
22.二叉树的最深公共祖先思想：最深是后序遍历，公共祖先说明最终一个在左一个再右。先获得左右值，对左右值与NULL的关系做判断。详见236
23.对于二叉搜索树的最深公共祖先就是满足：根节点大于一个小于一个的。所以做遍历就可以。详见325
24.二叉搜索树的插入就是不断寻找直到NULL，并且为了插入还要用到双指针，详见701
25.二叉搜索树的删除方法：分情况：
1）树中没有该节点，直接返回
2）树中有该节点且该节点为叶子节点——直接删除
3）树中有该节点且该节点左右有一个为空——直接返回另一个
4）树中有该节点且左右均不为空——寻找右子树最左侧A，把左子树放到A的左边。再把该节点右子树直接拼上去。
26.修剪二叉搜索树，就是改变左右节点。处理后左节点作为左节点，右节点同理。根据搜索树特性，获得处理后的结果。详见669
