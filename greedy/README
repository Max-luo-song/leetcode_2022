1.贪心没有固定模板，就是按照局部最优推出整体最优来计算。整体的方法就是多看，强化思想的同时增加代码实现能力
2.贪心一般要排序，按照最值策略做决策(大的给大的，小的给小的)。详见455
3.对于摆动序列问题，将数字图形化。摆动部分就是转折点。对于转折点的统计，用prediff和curdiff的符号差异做处理。同时在数字的统计上，默认右侧有一个转折点(result=1，因为有当前差，所以索引为nums.size()-1)。详见376
4.对于最大子数组和问题，要求连续的情况下有两种思路：1.动态规划，找temp[i-1]+nums[i]和nums[i]的大的作为temp[i] 2.贪心，如果前面count出现负数了，即使归零从下一个开始统计。但两种方法都要设置一个max_one保存最大值。详见53
5.买卖股票问题：
1）无手续费：学一种思路，nums[2]-num[0] = nums[2]-nums[1]+nums[1]-nums[0]。这样就变成了求相邻差，要最大就统计相邻差是正的就可以。详见122
2）有手续费：对于有手续费有三种情况：买入(当前值低于最小值)、获利(利润增加，卖出价格-手续费-最小值作为最小值，可以不真的卖出，统计利润就行)、不操作(卖出价格大于最小值，但小于最小值加手续费)。详见714
6.跳跃游戏问题(求每步最大覆盖范围)
1）判断是否能够跳到最后：用cover维护最最右cover = max(cover,i+nums[i])。把cover和最后时刻比较，判断是否能够到达最后。详见55
2）判断跳到最远至少几步问题：步数增加条件是当前位置已经处于之前一步能到达的最远距离，要多加一步往后跳了。维护两个变量：cur_cover和next_cover，next_cover使用max(next_cover,i+nums[i])维护，当i==cur_cover时count++，对cur_cover赋值，同时判断是否到达最后。详见45
7.对于K次取反数组最大值记录一种思路：按照绝对值从大到小排序，然后从左到右把负数取反。最终对最小值进行操作。详见1005
8.加油站问题，对情况分成三类分析：1）汽油总数<消耗——一定到不了 2）可以从0开始——每段路剩下的都大于>=0 3）不可以从0开始，有负值但总体满足。从后往前，寻找能够补平的作为开始节点。详见134
9.双维度问题——明显看出有两个层面的要求
1）分发糖果：从左向右保证右边的大于左边的，从右向左在max(num[i-1],num[i]+1)选择，保证自己符合也保证上一个维度符合。详见135
2）身高重建队列：两个维度问题，选择一个维度排序然后按照另一个维度处理。本题选择身高从高到低排序，再按照序号进行插入。详见406
注意自定义sort用法
static bool cmp(const vector<int>& a, const vector<int>& b) {
	return a[0] < b[0] // 从小到大
	return a[0] > b[0] // 从大到小
}
sort(nums.begin(),nums.end(),cmp);
10.重叠区间问题(区间问题也算是两个维度的问题，要按照区间一侧进行排序)
1）气球引爆最小箭数问题：按照左边界排序，当num[i]的左>nums[i-1]的右时说明无重叠要增加箭数。同时更新右边界，应该是最左右边界min(为了留给右边的尽可能大避免左重叠右重叠情况，我们以左优先)。详见452
2）为求无重叠区间，要删去重叠区间。本题求删去个数转个角度，总区间数-不重叠数。不重叠数计算按照右边界排序，出现right<nums[i][0]时++，再更新right，最后做减法。详见435
3）划分字母区间，本题不算贪心但思想比较少见。统计每个字符的最大索引，再次遍历时时刻更新当前最右索引right,当i=right时说明一个区间结束。下一个区间从right+1开始。详见763
4）合并重叠区间，先根据左区间排序，for中确定左，while中循环右。因为使用上一个，对最后一个元素特殊处理。详见56
11.对多位数字做操作。可以用to_string先变成string，最后再用stoi变成int。提供一种思路：寻找比当前数小的最大数满足递增，利用num[i-1]--,nums[i]变9(所有后面的)。一个处理细节是保存位置，最后统一变9.详见738
12.监控二叉树最好是叶子节点，从下往上后序遍历。设置3个状态判断，子节点全部覆盖，父节点不需覆盖。有一个没覆盖，父节点要相机。子节点有一个相机，子节点覆盖。特殊处理是根节点，以及叶子认为被覆盖。详见968
